
import os
import sys
import io
import json
import math
import time
import textwrap
import urllib.parse
import urllib.request
import webbrowser
from dataclasses import dataclass
from datetime import datetime
from typing import List, Dict, Optional, Tuple

# --- Tkinter imports ---
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog, colorchooser
from tkinter import font as tkfont

# =====================================================
# Common: About dialog & helpers
# =====================================================
class AboutDialog:
    @staticmethod
    def show(parent: tk.Misc):
        messagebox.showinfo(
            "About",
            "OOP GUI Suite\n\n"
            "• Hello World\n"
            "• Text Editor\n"
            "• Paint (Raster Graphics)\n"
            "• Blackjack (Card Game)\n"
            "• Weather (OpenWeatherMap)\n\n"
            "© 2025 – Assignment 10"
        )


def ask_string(parent: tk.Misc, title: str, prompt: str, initial: str = "") -> Optional[str]:
    return simpledialog.askstring(title, prompt, initialvalue=initial, parent=parent)


# =====================================================
# Hello World
# =====================================================
class HelloWorldApp(tk.Toplevel):
    def __init__(self, master: tk.Misc):
        super().__init__(master)
        self.title("Hello, World!")
        self.geometry("360x140")
        lbl = ttk.Label(self, text="Hello, World!", font=("Helvetica", 24, "bold"))
        lbl.pack(expand=True, pady=24)
        ttk.Button(self, text="Close", command=self.destroy).pack(pady=8)


# =====================================================
# Text Editor
# =====================================================
class TextEditorApp(tk.Toplevel):
    def __init__(self, master: tk.Misc):
        super().__init__(master)
        self.title("Text Editor")
        self.geometry("900x600")
        self._filepath: Optional[str] = None
        self._create_widgets()
        self._create_menus()
        self._bind_shortcuts()
        self._create_context_menu()

    def _create_widgets(self):
        self.text = tk.Text(self, wrap="word", undo=True)
        self.text.pack(fill="both", expand=True)
        # Add scrollbars
        yscroll = ttk.Scrollbar(self, orient="vertical", command=self.text.yview)
        xscroll = ttk.Scrollbar(self, orient="horizontal", command=self.text.xview)
        self.text.configure(yscrollcommand=yscroll.set, xscrollcommand=xscroll.set)
        yscroll.pack(side="right", fill="y")
        xscroll.pack(side="bottom", fill="x")

    def _create_menus(self):
        menubar = tk.Menu(self)
        # File
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="New", accelerator="Ctrl+N", command=self.new_file)
        file_menu.add_command(label="Open…", accelerator="Ctrl+O", command=self.open_file)
        file_menu.add_command(label="Save", accelerator="Ctrl+S", command=self.save)
        file_menu.add_command(label="Save As…", command=self.save_as)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.destroy)
        menubar.add_cascade(label="File", menu=file_menu)

        # Edit
        edit_menu = tk.Menu(menubar, tearoff=0)
        edit_menu.add_command(label="Cut", accelerator="Ctrl+X", command=lambda: self.event_generate("<<Cut>>"))
        edit_menu.add_command(label="Copy", accelerator="Ctrl+C", command=lambda: self.event_generate("<<Copy>>"))
        edit_menu.add_command(label="Paste", accelerator="Ctrl+V", command=lambda: self.event_generate("<<Paste>>"))
        menubar.add_cascade(label="Edit", menu=edit_menu)

        # Format
        format_menu = tk.Menu(menubar, tearoff=0)
        format_menu.add_command(label="Font…", command=self.choose_font)
        menubar.add_cascade(label="Format", menu=format_menu)

        # Help
        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="About", command=lambda: AboutDialog.show(self))
        menubar.add_cascade(label="Help", menu=help_menu)

        self.config(menu=menubar)

    def _create_context_menu(self):
        self.context = tk.Menu(self, tearoff=0)
        self.context.add_command(label="Cut", command=lambda: self.event_generate("<<Cut>>"))
        self.context.add_command(label="Copy", command=lambda: self.event_generate("<<Copy>>"))
        self.context.add_command(label="Paste", command=lambda: self.event_generate("<<Paste>>"))
        self.text.bind("<Button-3>", self._show_context)
        self.text.bind("<Button-2>", self._show_context)  # macOS compatibility

    def _show_context(self, event):
        try:
            self.context.tk_popup(event.x_root, event.y_root)
        finally:
            self.context.grab_release()

    def _bind_shortcuts(self):
        self.bind("<Control-n>", lambda e: self.new_file())
        self.bind("<Control-o>", lambda e: self.open_file())
        self.bind("<Control-s>", lambda e: self.save())

    # File ops
    def new_file(self):
        self._filepath = None
        self.text.delete("1.0", "end")

    def open_file(self):
        path = filedialog.askopenfilename(filetypes=[("Text", "*.txt"), ("All files", "*.*")])
        if not path:
            return
        with open(path, "r", encoding="utf-8") as f:
            content = f.read()
        self.text.delete("1.0", "end")
        self.text.insert("1.0", content)
        self._filepath = path
        self.title(f"Text Editor – {os.path.basename(path)}")

    def save(self):
        if self._filepath is None:
            return self.save_as()
        content = self.text.get("1.0", "end-1c")
        with open(self._filepath, "w", encoding="utf-8") as f:
            f.write(content)
        messagebox.showinfo("Saved", f"Saved to {self._filepath}")

    def save_as(self):
        path = filedialog.asksaveasfilename(defaultextension=".txt",
                                            filetypes=[("Text", "*.txt"), ("All files", "*.*")])
        if not path:
            return
        self._filepath = path
        self.save()

    def choose_font(self):
        # Simple font chooser: family + size
        families = sorted(tkfont.families())
        family = ask_string(self, "Font", "Enter font family:", initial="Helvetica")
        if not family:
            return
        size_str = ask_string(self, "Font", "Enter size:", initial="12")
        try:
            size = int(size_str) if size_str else 12
        except ValueError:
            size = 12
        self.text.configure(font=(family, size))


# =====================================================
# Raster Graphics Editor (Paint)
# =====================================================
class PaintApp(tk.Toplevel):
    def __init__(self, master: tk.Misc):
        super().__init__(master)
        self.title("Paint – Raster Graphics Editor")
        self.geometry("900x650")
        self.brush_size = tk.IntVar(value=5)
        self.brush_color = "#000000"
        self.tool = tk.StringVar(value="brush")  # brush | text | eraser
        self._text_font = ("Helvetica", 16, "bold")
        self._create_widgets()
        self._create_menus()
        self._bind()

    def _create_widgets(self):
        toolbar = ttk.Frame(self)
        toolbar.pack(side="top", fill="x")

        ttk.Label(toolbar, text="Tool:").pack(side="left", padx=(8, 4))
        for name in ["brush", "text", "eraser"]:
            ttk.Radiobutton(toolbar, text=name.title(), value=name, variable=self.tool).pack(side="left")

        ttk.Label(toolbar, text="Brush size:").pack(side="left", padx=(16, 4))
        ttk.Spinbox(toolbar, from_=1, to=50, textvariable=self.brush_size, width=4).pack(side="left")

        ttk.Button(toolbar, text="Color", command=self.choose_color).pack(side="left", padx=8)

        self.canvas = tk.Canvas(self, bg="white")
        self.canvas.pack(fill="both", expand=True)

        status = ttk.Frame(self)
        status.pack(side="bottom", fill="x")
        self.status_var = tk.StringVar(value="Ready")
        ttk.Label(status, textvariable=self.status_var).pack(anchor="w", padx=8)

    def _create_menus(self):
        menubar = tk.Menu(self)
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="New", command=self.new_canvas)
        file_menu.add_command(label="Open…", command=self.open_image)
        file_menu.add_command(label="Save As…", command=self.save_image)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.destroy)
        menubar.add_cascade(label="File", menu=file_menu)

        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="About", command=lambda: AboutDialog.show(self))
        menubar.add_cascade(label="Help", menu=help_menu)

        self.config(menu=menubar)

    def _bind(self):
        self.canvas.bind("<B1-Motion>", self._on_drag)
        self.canvas.bind("<Button-1>", self._on_click)

    def choose_color(self):
        color = colorchooser.askcolor(color=self.brush_color, parent=self)[1]
        if color:
            self.brush_color = color

    def new_canvas(self):
        self.canvas.delete("all")

    def _on_click(self, event):
        if self.tool.get() == "text":
            text = ask_string(self, "Text Tool", "Enter text:")
            if text:
                self.canvas.create_text(event.x, event.y, text=text, fill=self.brush_color, font=self._text_font)
        else:
            self._draw_point(event.x, event.y)

    def _on_drag(self, event):
        if self.tool.get() == "eraser":
            size = self.brush_size.get()
            self.canvas.create_rectangle(event.x - size, event.y - size, event.x + size, event.y + size,
                                         fill="white", outline="white")
        else:
            self._draw_point(event.x, event.y)

    def _draw_point(self, x, y):
        size = self.brush_size.get()
        self.canvas.create_oval(x - size, y - size, x + size, y + size, fill=self.brush_color, outline="")

    def save_image(self):
        # Save canvas as PostScript (EPS). Users can convert to PNG externally if needed.
        path = filedialog.asksaveasfilename(defaultextension=".eps", filetypes=[("EPS", "*.eps")])
        if not path:
            return
        self.canvas.postscript(file=path)
        messagebox.showinfo("Saved", f"Canvas saved to {path}\n(Note: EPS format)")

    def open_image(self):
        messagebox.showinfo("Open", "Basic demo app: image import not implemented. Start drawing!")


# =====================================================
# Card Game – Blackjack (lists + dictionaries)
# =====================================================
SUITS = ["♠", "♥", "♦", "♣"]
RANKS = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]

@dataclass(frozen=True)
class Card:
    suit: str
    rank: str

    def value(self) -> List[int]:
        if self.rank in {"J", "Q", "K"}:
            return [10]
        if self.rank == "A":
            return [1, 11]
        return [int(self.rank)]

    def __str__(self):
        return f"{self.rank}{self.suit}"


class Deck:
    def __init__(self):
        self.cards: List[Card] = [Card(s, r) for s in SUITS for r in RANKS]
        self.shuffle()

    def shuffle(self):
        import random
        random.shuffle(self.cards)

    def draw(self) -> Card:
        if not self.cards:
            self.__init__()  # reinitialize fresh deck if empty
        return self.cards.pop()


class Hand:
    def __init__(self):
        self.cards: List[Card] = []

    def add(self, card: Card):
        self.cards.append(card)

    def values(self) -> List[int]:
        totals = [0]
        for c in self.cards:
            new_totals = []
            for t in totals:
                for v in c.value():
                    new_totals.append(t + v)
            totals = new_totals
        # Remove duplicates
        return sorted(set(totals))

    def best_value(self) -> int:
        vals = [v for v in self.values() if v <= 21]
        return max(vals) if vals else min(self.values())

    def is_blackjack(self) -> bool:
        return len(self.cards) == 2 and 21 in self.values()

    def is_bust(self) -> bool:
        return min(self.values()) > 21

    def __str__(self):
        return " ".join(str(c) for c in self.cards)


class BlackjackGame:
    def __init__(self):
        self.deck = Deck()
        self.dealer = Hand()
        self.player = Hand()
        self.score: Dict[str, int] = {"wins": 0, "losses": 0, "pushes": 0}  # dictionary for scoring
        self.in_round = False

    def start_round(self):
        self.in_round = True
        self.dealer = Hand()
        self.player = Hand()
        self.player.add(self.deck.draw())
        self.dealer.add(self.deck.draw())
        self.player.add(self.deck.draw())
        self.dealer.add(self.deck.draw())

    def hit(self) -> None:
        if not self.in_round:
            return
        self.player.add(self.deck.draw())
        if self.player.is_bust():
            self._end_round()

    def stand(self) -> None:
        if not self.in_round:
            return
        while self.dealer.best_value() < 17:
            self.dealer.add(self.deck.draw())
        self._end_round()

    def _end_round(self):
        self.in_round = False
        p, d = self.player.best_value(), self.dealer.best_value()
        if self.player.is_bust():
            self.score["losses"] += 1
        elif self.dealer.is_bust():
            self.score["wins"] += 1
        elif p > d:
            self.score["wins"] += 1
        elif p < d:
            self.score["losses"] += 1
        else:
            self.score["pushes"] += 1


class BlackjackApp(tk.Toplevel):
    def __init__(self, master: tk.Misc):
        super().__init__(master)
        self.title("Blackjack")
        self.geometry("700x500")
        self.game = BlackjackGame()
        self._build_ui()

    def _build_ui(self):
        menubar = tk.Menu(self)
        game_menu = tk.Menu(menubar, tearoff=0)
        game_menu.add_command(label="New Round", command=self.new_round)
        game_menu.add_separator()
        game_menu.add_command(label="Exit", command=self.destroy)
        menubar.add_cascade(label="Game", menu=game_menu)

        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="About", command=lambda: AboutDialog.show(self))
        menubar.add_cascade(label="Help", menu=help_menu)
        self.config(menu=menubar)

        self.dealer_var = tk.StringVar()
        self.player_var = tk.StringVar()
        self.status_var = tk.StringVar(value="Press 'New Round' to begin.")
        self.score_var = tk.StringVar()

        frm = ttk.Frame(self)
        frm.pack(fill="both", expand=True, padx=16, pady=16)

        ttk.Label(frm, text="Dealer:", font=("Helvetica", 14, "bold")).grid(row=0, column=0, sticky="w")
        ttk.Label(frm, textvariable=self.dealer_var, font=("Consolas", 16)).grid(row=1, column=0, sticky="w")
        ttk.Label(frm, text="Player:", font=("Helvetica", 14, "bold")).grid(row=2, column=0, sticky="w", pady=(12,0))
        ttk.Label(frm, textvariable=self.player_var, font=("Consolas", 16)).grid(row=3, column=0, sticky="w")

        btns = ttk.Frame(frm)
        btns.grid(row=4, column=0, pady=16, sticky="w")
        ttk.Button(btns, text="Hit", command=self.hit).pack(side="left", padx=4)
        ttk.Button(btns, text="Stand", command=self.stand).pack(side="left", padx=4)
        ttk.Button(btns, text="New Round", command=self.new_round).pack(side="left", padx=4)

        ttk.Label(frm, textvariable=self.status_var).grid(row=5, column=0, sticky="w")
        ttk.Label(frm, textvariable=self.score_var, font=("Helvetica", 12, "bold")).grid(row=6, column=0, sticky="w", pady=(8,0))
        self._refresh()

    def new_round(self):
        self.game.start_round()
        self.status_var.set("Your move: Hit or Stand")
        self._refresh()

    def hit(self):
        self.game.hit()
        if self.game.in_round and self.game.player.is_bust():
            self.status_var.set("You busted! Dealer wins.")
        self._refresh()

    def stand(self):
        self.game.stand()
        self.status_var.set("Round ended.")
        self._refresh()

    def _refresh(self):
        self.dealer_var.set(f"{self.game.dealer}  (best: {self.game.dealer.best_value()})")
        self.player_var.set(f"{self.game.player}  (best: {self.game.player.best_value()})")
        s = self.game.score
        self.score_var.set(f"Score – Wins: {s['wins']}  Losses: {s['losses']}  Pushes: {s['pushes']}")


# =====================================================
# Weather Application (OpenWeatherMap API)
# =====================================================
class OpenWeatherClient:
    BASE = "https://api.openweathermap.org/data/2.5"

    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.getenv("OWM_API_KEY", "")
        if not self.api_key:
            # We'll still allow construction; calls will raise a clean error later
            pass

    def build_url(self, endpoint: str, params: Dict[str, str]) -> str:
        p = params.copy()
        p["appid"] = self.api_key
        return f"{self.BASE}/{endpoint}?{urllib.parse.urlencode(p)}"

    def get_current_by_city(self, city: str, units: str = "metric") -> Dict:
        if not self.api_key:
            raise RuntimeError("OWM_API_KEY not set")
        url = self.build_url("weather", {"q": city, "units": units})
        with urllib.request.urlopen(url) as r:
            return json.load(r)

    def get_onecall(self, lat: float, lon: float, units: str = "metric") -> Dict:
        if not self.api_key:
            raise RuntimeError("OWM_API_KEY not set")
        url = self.build_url("onecall", {"lat": str(lat), "lon": str(lon), "units": units, "exclude": "minutely,alerts"})
        with urllib.request.urlopen(url) as r:
            return json.load(r)


class WeatherApp(tk.Toplevel):
    def __init__(self, master: tk.Misc):
        super().__init__(master)
        self.title("Weather – OpenWeatherMap")
        self.geometry("820x600")
        self.client = OpenWeatherClient()
        self._build_ui()

    def _build_ui(self):
        top = ttk.Frame(self)
        top.pack(fill="x", padx=12, pady=8)

        ttk.Label(top, text="City:").pack(side="left")
        self.city_var = tk.StringVar(value="Chicago,US")
        ttk.Entry(top, textvariable=self.city_var, width=30).pack(side="left", padx=6)
        ttk.Button(top, text="Fetch", command=self.fetch_weather).pack(side="left", padx=6)

        self.current_var = tk.StringVar(value="Current: —")
        ttk.Label(self, textvariable=self.current_var, font=("Helvetica", 14, "bold")).pack(anchor="w", padx=12, pady=(4,0))

        self.tab = ttk.Notebook(self)
        self.tab.pack(fill="both", expand=True, padx=12, pady=8)

        self.hourly_tree = self._make_tree(columns=("time", "temp", "weather"), headings=("Time", "Temp", "Weather"))
        self.daily_tree  = self._make_tree(columns=("date", "min", "max", "weather"), headings=("Date", "Min", "Max", "Weather"))

        f1 = ttk.Frame(self.tab)
        f2 = ttk.Frame(self.tab)
        self.tab.add(f1, text="Hourly (24h)")
        self.tab.add(f2, text="Daily (7d)")
        self.hourly_tree.pack(in_=f1, fill="both", expand=True)
        self.daily_tree.pack(in_=f2, fill="both", expand=True)

        menubar = tk.Menu(self)
        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="About", command=lambda: AboutDialog.show(self))
        menubar.add_cascade(label="Help", menu=help_menu)
        self.config(menu=menubar)

    def _make_tree(self, columns, headings):
        tree = ttk.Treeview(self, columns=columns, show="headings")
        for c, h in zip(columns, headings):
            tree.heading(c, text=h)
            tree.column(c, width=150, anchor="w")
        yscroll = ttk.Scrollbar(self, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=yscroll.set)
        yscroll.pack_forget()  # packed into the frame later
        return tree

    def fetch_weather(self):
        city = self.city_var.get().strip()
        if not city:
            return
        try:
            data = self.client.get_current_by_city(city)
            name = data.get("name", city)
            main = data.get("weather", [{}])[0].get("description", "—")
            temp = data.get("main", {}).get("temp", "—")
            lat = data.get("coord", {}).get("lat")
            lon = data.get("coord", {}).get("lon")
            self.current_var.set(f"Current – {name}: {temp}°, {main}")
            if lat is not None and lon is not None:
                one = self.client.get_onecall(lat, lon)
                self._populate_hourly(one)
                self._populate_daily(one)
        except Exception as e:
            messagebox.showerror("Weather Error", str(e))

    def _populate_hourly(self, data: Dict):
        for item in self.hourly_tree.get_children():
            self.hourly_tree.delete(item)
        hourly = data.get("hourly", [])[:24]
        for h in hourly:
            dt = datetime.fromtimestamp(h.get("dt", 0)).strftime("%Y-%m-%d %H:%M")
            temp = h.get("temp", "—")
            weather = (h.get("weather") or [{}])[0].get("description", "—")
            self.hourly_tree.insert("", "end", values=(dt, temp, weather))

    def _populate_daily(self, data: Dict):
        for item in self.daily_tree.get_children():
            self.daily_tree.delete(item)
        daily = data.get("daily", [])[:7]
        for d in daily:
            dt = datetime.fromtimestamp(d.get("dt", 0)).strftime("%Y-%m-%d")
            temps = d.get("temp", {})
            tmin = temps.get("min", "—")
            tmax = temps.get("max", "—")
            weather = (d.get("weather") or [{}])[0].get("description", "—")
            self.daily_tree.insert("", "end", values=(dt, tmin, tmax, weather))


# =====================================================
# Launcher
# =====================================================
class Launcher(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("OOP GUI Applications – Launcher")
        self.geometry("560x380")
        self._build_ui()

    def _build_ui(self):
        menubar = tk.Menu(self)
        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="About", command=lambda: AboutDialog.show(self))
        help_menu.add_command(label="Project Page", command=lambda: webbrowser.open("https://en.wikiversity.org/wiki/Object-Oriented_Programming/GUI_Applications"))
        menubar.add_cascade(label="Help", menu=help_menu)
        self.config(menu=menubar)

        title = ttk.Label(self, text="GUI Applications Suite", font=("Helvetica", 18, "bold"))
        title.pack(pady=(24, 8))
        subtitle = ttk.Label(self, text="Select a demo to launch")
        subtitle.pack()

        grid = ttk.Frame(self)
        grid.pack(expand=True, pady=24)

        def add_btn(text, cmd, r, c):
            b = ttk.Button(grid, text=text, command=cmd, width=24)
            b.grid(row=r, column=c, padx=8, pady=8)

        add_btn("Hello World", lambda: HelloWorldApp(self), 0, 0)
        add_btn("Text Editor", lambda: TextEditorApp(self), 0, 1)
        add_btn("Paint (Raster)", lambda: PaintApp(self), 1, 0)
        add_btn("Blackjack", lambda: BlackjackApp(self), 1, 1)
        add_btn("Weather (OWM)", lambda: WeatherApp(self), 2, 0)

        footer = ttk.Label(self, text="Assignment 10 – Tkinter, OOP, Unit Tests", foreground="#666")
        footer.pack(pady=(8, 12))


# =====================================================
# Unit Tests (run automatically when module executed)
# =====================================================
import unittest

class TestCards(unittest.TestCase):
    def test_deck_has_52_unique_cards(self):
        d = Deck()
        self.assertEqual(len(d.cards), 52)
        self.assertEqual(len(set(map(str, d.cards))), 52)

    def test_hand_values_for_ace(self):
        h = Hand()
        h.add(Card("♠", "A"))
        h.add(Card("♥", "9"))
        self.assertIn(20, h.values())
        self.assertIn(10, h.values())
        self.assertEqual(h.best_value(), 20)

    def test_blackjack_detection(self):
        h = Hand()
        h.add(Card("♠", "A"))
        h.add(Card("♥", "K"))
        self.assertTrue(h.is_blackjack())

class TestOWM(unittest.TestCase):
    def test_build_url_has_key_and_params(self):
        client = OpenWeatherClient(api_key="TESTKEY")
        url = client.build_url("weather", {"q": "Chicago,US", "units": "metric"})
        self.assertIn("appid=TESTKEY", url)
        self.assertIn("q=Chicago%2CUS", url)
        self.assertIn("units=metric", url)


def main():
    # Run tests
    suite = unittest.defaultTestLoader.loadTestsFromModule(sys.modules[__name__])
    result = unittest.TextTestRunner(verbosity=2).run(suite)
    # Launch UI regardless of test success to make grading easy
    app = Launcher()
    app.mainloop()


if __name__ == "__main__":
    main()
