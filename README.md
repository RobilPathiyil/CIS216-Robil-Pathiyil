# CIS216-Robil-Pathiyil
I am taking this course because it is part of my major's coursework (cybersecurity) as it will help me strenthen my skills in programming and problem solving that is used in the field. For this course, I decided to use Python as my programming language because it is beginner-friendly, widely used in many fields like data science, web development, and cybersecurity, and has a simple syntax that makes it easier to learn and apply quickly. I intend to use Python not only for completing class assignments but also for building projects in cybersecurity, automation, and potentially even artificial intelligence applications.  
In session 2 I learned how to convert requirements into a concise, organized object-oriented module during this workshop. In order to maintain separation of concerns, I implemented input validation and error handling, developed a BMI calculator as a BMICalculator class with explicit public methods (metric/US) and private conversion helpers, and maintained all I/O in main.py. I used Google-style docstrings, consistent naming, type hints, and constants, as well as UML-to-code thinking (encapsulation, method design, and API clarity) in my adoption of PEP 8/PEP 257. My code is simpler to read, test, and expand thanks to these practices. In order to prepare for entry-level IT/cyber roles (such as help desk, SOC analyst, and junior automation) after I graduate from DePaul and enter the tech industry in 2026, I'll use this strategy throughout my coursework and as I develop a cybersecurity-focused portfolio. I'll automate small tools, write clean scripts, and document everything in Git.
In session 3, I learned about building a BMI calculator with a dedicated class, public calculation methods, and private conversion helpers allowed me to practice object-oriented methods during this session. I added type hints, constants, input validation, and Google-style docstrings in accordance with PEP 8/PEP 257. To maintain separation of concerns, I maintained all input and output in main.py. This improved my comprehension of documentation norms, constructor/helper method design, and encapsulation. Because the code complies with generally recognized standards, I'll use these techniques to write more understandable, tested modules and work in teams more successfully in my future coursework and cybersecurity/computer science career.
Lesson 4 we focused on making programs robust and predictable by verifying inputs and enforcing invariants. I learned to validate both type and range at the boundaries (user input/CLI) and to enforce parameter contracts inside classesâ€”e.g., property setters for kilograms, meters, pounds, feet, and inches raise TypeError/ValueError on bad data, while bmi remains a read-only computed property. We contrasted LBYL (check before doing) for user input with EAFP (try and handle) for operations that may fail, and added assertions for internal assumptions (positive canonical units) to catch logic errors early. Finally, we wrapped control flow in exception handling to fail gracefully with clear messages. Overall, the lesson reinforced defensive programming: validate at the edges, keep objects in a consistent state, and communicate errors clearly.
