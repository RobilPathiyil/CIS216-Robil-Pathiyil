# CIS216-Robil-Pathiyil
I am taking this course because it is part of my major's coursework (cybersecurity) as it will help me strenthen my skills in programming and problem solving that is used in the field. For this course, I decided to use Python as my programming language because it is beginner-friendly, widely used in many fields like data science, web development, and cybersecurity, and has a simple syntax that makes it easier to learn and apply quickly. I intend to use Python not only for completing class assignments but also for building projects in cybersecurity, automation, and potentially even artificial intelligence applications.  
In session 2 I learned how to convert requirements into a concise, organized object-oriented module during this workshop. In order to maintain separation of concerns, I implemented input validation and error handling, developed a BMI calculator as a BMICalculator class with explicit public methods (metric/US) and private conversion helpers, and maintained all I/O in main.py. I used Google-style docstrings, consistent naming, type hints, and constants, as well as UML-to-code thinking (encapsulation, method design, and API clarity) in my adoption of PEP 8/PEP 257. My code is simpler to read, test, and expand thanks to these practices. In order to prepare for entry-level IT/cyber roles (such as help desk, SOC analyst, and junior automation) after I graduate from DePaul and enter the tech industry in 2026, I'll use this strategy throughout my coursework and as I develop a cybersecurity-focused portfolio. I'll automate small tools, write clean scripts, and document everything in Git.
In session 3, I learned about building a BMI calculator with a dedicated class, public calculation methods, and private conversion helpers allowed me to practice object-oriented methods during this session. I added type hints, constants, input validation, and Google-style docstrings in accordance with PEP 8/PEP 257. To maintain separation of concerns, I maintained all input and output in main.py. This improved my comprehension of documentation norms, constructor/helper method design, and encapsulation. Because the code complies with generally recognized standards, I'll use these techniques to write more understandable, tested modules and work in teams more successfully in my future coursework and cybersecurity/computer science career.
Lesson 4 we focused on making programs robust and predictable by verifying inputs and enforcing invariants. I learned to validate both type and range at the boundaries (user input/CLI) and to enforce parameter contracts inside classes—e.g., property setters for kilograms, meters, pounds, feet, and inches raise TypeError/ValueError on bad data, while bmi remains a read-only computed property. We contrasted LBYL (check before doing) for user input with EAFP (try and handle) for operations that may fail, and added assertions for internal assumptions (positive canonical units) to catch logic errors early. Finally, we wrapped control flow in exception handling to fail gracefully with clear messages. Overall, the lesson reinforced defensive programming: validate at the edges, keep objects in a consistent state, and communicate errors clearly.
Lesson 5 taught me how crucial test-driven development (TDD) and unit testing are to creating dependable software. I worked on creating brief, targeted tests that verify distinct methods separately and measure coverage to make sure every line of code is used. I learned how tests promote cleaner, more modular design, help identify issues early, and make reworking safer during this process. Additionally, I discovered that although achieving 100% coverage is a good objective, it shouldn't take the place of other testing methods like compliance or integration testing. In order to write new features with confidence, reduce problems, and keep my codebase maintainable, I intend to use unit tests and TDD to direct my development approach moving forward.
In assignment 6, we learned about inheritance, one of the core principles of object-oriented programming. Inheritance allows a subclass (child class) to acquire the properties and methods of a superclass (parent class), promoting code reuse and reducing redundancy. We also saw how subclasses can override methods to provide their own implementation while still having the option to call base class functionality. The lesson covered different types of inheritance, such as single, multiple, and multilevel inheritance, and introduced design constraints like singleness, static hierarchy, and visibility. We also discussed the potential drawbacks of inheritance, such as the “fragile base class problem,” and how composition can sometimes be a better alternative. Overall, inheritance provides a powerful way to structure programs, create hierarchies of related classes, and extend functionality while maintaining organized, reusable code.
In this session, I learned how polymorphism allows objects of different subclasses to be treated as instances of a common base class while still executing their own unique behaviors. By overriding methods such as pay() in my Manager, SalesEmployee, and HourlyEmployee classes, I saw how dynamic dispatch ensures the correct implementation is called even when the object is referenced as an Employee. This makes programs more flexible, reusable, and easier to extend without changing existing code. I plan to apply this skill in my educational journey by designing modular, testable projects, and in my future cybersecurity/IT career by coding to interfaces so that systems can adapt to new requirements without major rewrites.
In lesson 7, I learned how to create Graphical User Interface (GUI) applications using object-oriented programming concepts. I built a “Hello World” window and a simple text editor that included scrollbars and menu options, which helped me understand how event-driven programming works. Through this process, I gained experience working with GUI frameworks, organizing code into classes and methods, and improving program functionality for better user interaction. I plan to apply these skills in future projects that require interactive designs, such as creating cybersecurity dashboards or user-friendly tools to visualize data. These lessons have strengthened both my programming and problem-solving abilities, preparing me for real-world software development and IT career opportunities.
Un this lesson, I learned how project planning and management help keep software development organized and goal-oriented. I gained a better understanding of the main project phases—initiating, planning, executing, monitoring, and closing—and how each plays a role in achieving successful outcomes. I also learned about important tools such as Gantt charts, work breakdown structures (WBS), and project management software, which help visualize tasks, track progress, and manage resources effectively. This experience taught me how to define objectives, scope, deliverables, and stakeholder roles clearly from the start. I plan to apply these project management principles to future programming and cybersecurity projects to improve time management, quality assurance, and overall productivity.
In this lesson
, I learned how to create and manage object-oriented GUI applications. I practiced using classes, methods, and attributes to build interactive programs that respond to user input through windows, buttons, and menus. This assignment improved my understanding of event-driven programming, interface design, and how to use lists and dictionaries within GUI programs to organize data. I also gained experience with project planning by designing UML class diagrams and testing each component for functionality. These skills are valuable as I continue developing more advanced software and prepare for future projects in cybersecurity and application development.
